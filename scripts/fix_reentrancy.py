import re

def fix_reentrancy_vulnerability(contract_code: str) -> str:
    # Use a regular expression to find the withdraw function
    pattern = r"function\s+withdraw\s*\(\s*\)\s*public\s*{"
    match = re.search(pattern, contract_code, re.MULTILINE)
    if match:
        # Get the start and end indices of the function
        start_index = match.start()
        end_index = contract_code.index("}", start_index)


        # Extract the function code
        function_code = contract_code[start_index:end_index+1]

        # Check if the function is vulnerable to reentrancy
        if "balance = 0" in function_code and "require" in function_code:
            fixed_function_code = swap_lines(function_code, "balance = 0", "require")


            # Replace the original function code with the fixed version
            contract_code = contract_code[:start_index] + fixed_function_code + contract_code[end_index+1:]

    return contract_code

def swap_lines(string: str, pattern1: str, pattern2: str) -> str:
    # Use the finditer method to find all lines that match the first pattern
    matches1 = list(re.finditer(pattern1, string, re.MULTILINE))
    # Use the finditer method to find all lines that match the second pattern
    matches2 = list(re.finditer(pattern2, string, re.MULTILINE))
    if matches1 and matches2:
        # Get the start and end indices of the first matching line for each pattern
        start_index1 = matches1[0].start()
        end_index1 = string.index("\n", start_index1)
        if end_index1 == -1:
            end_index1 = len(string)
        start_index2 = matches2[0].start()
        end_index2 = string.index("\n", start_index2)
        if end_index2 == -1:
            end_index2 = len(string)
        if end_index1 > start_index2:
            return string
        # Extract the lines that match the patterns
        line1 = string[start_index1:end_index1]
        line2 = string[start_index2:end_index2]

        # Swap the positions of the lines
        string = string[:start_index1] + line2 + string[end_index1:start_index2] + line1 + string[end_index2:]

    return string

# Test the fixer on the ReentrancyVulnerability contract
contract_code = """
pragma solidity ^0.7.0;

contract ReentrancyVulnerability {
    uint public balance;

    function deposit() public payable {
        balance += msg.value;
    }

    function withdraw() public {
        require(msg.sender.call.value(balance)());
        balance = 0;


        
    }
}
"""
with open("/home/nikolas/Documents/smartcontracts/Vulnerable_contracts/ReentrancyVulnerability.sol", "r+") as f:
    fixed_contract_code = fix_reentrancy_vulnerability(f.read())
    print(fixed_contract_code)
    f.seek(0)
    f.write(fixed_contract_code)
    f.truncate()
    f.close()
#fixed_contract_code = fix_reentrancy_vulnerability(contract_code)
#print(fixed_contract_code)